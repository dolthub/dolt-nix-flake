// Copyright 2023 Dolthub, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

var FilePattern = "%s.zip"
var DownloadPath = "https://github.com/dolthub/dolt/archive/"
var ExtractedDirPattern = "dolt-%s"

var GeneratedFileWarning = `// WARNING: This file is generated by main.go in github.com/dolthub/dolt-nix-flake.
`

// This is our workspace where we will create file trees, hash them, etc.
// Be sure to clean it up with `env.Close`
type Environment struct {
	// Paths to required external programs we invoke.
	NixHashProg string
	GoProg      string
	UnzipProg   string

	BaseDir string

	SourceZipUrl string
	SourceZip    string

	// Extracted source code.
	SourceDir string

	GoModuleDir string
	GoCacheDir  string
	GoPathDir   string

	GoDownloadPath      string
	GoDownloadSumDBPath string
}

func (e *Environment) Close() {
	os.RemoveAll(e.BaseDir)
}

func NewEnvironment(revision string) (*Environment, error) {
	nixhash, err := exec.LookPath("nix-hash")
	if err != nil {
		return nil, fmt.Errorf("did not find required executable, nix-hash, in PATH: %v", err)
	}
	goprog, err := exec.LookPath("go")
	if err != nil {
		return nil, fmt.Errorf("did not find required executable, go, in PATH: %v", err)
	}
	unzipprog, err := exec.LookPath("unzip")
	if err != nil {
		return nil, fmt.Errorf("did not find required executable, unzip, in PATH: %v", err)
	}
	dir, err := os.MkdirTemp("", "dolt-nix-flake-*")
	if err != nil {
		return nil, fmt.Errorf("could not create temp dir: %v", err)
	}

	filename := fmt.Sprintf(FilePattern, revision)
	extracteddir := fmt.Sprintf(ExtractedDirPattern, os.Args[1])

	env := new(Environment)
	env.NixHashProg = nixhash
	env.GoProg = goprog
	env.UnzipProg = unzipprog
	env.BaseDir = dir
	env.SourceZipUrl = DownloadPath + filename
	env.SourceZip = filepath.Join(env.BaseDir, filename)
	env.SourceDir = filepath.Join(env.BaseDir, extracteddir)
	env.GoModuleDir = filepath.Join(env.SourceDir, "go")
	env.GoCacheDir = filepath.Join(env.BaseDir, "go-cache")
	env.GoPathDir = filepath.Join(env.BaseDir, "go")
	env.GoDownloadPath = filepath.Join(env.GoPathDir, "pkg", "mod", "cache", "download")
	env.GoDownloadSumDBPath = filepath.Join(env.GoDownloadPath, "sumdb")

	err = os.MkdirAll(env.GoCacheDir, 0777)
	if err != nil {
		return nil, fmt.Errorf("could not create temporary GOCACHE directory %v: %w", env.GoCacheDir, err)
	}
	err = os.MkdirAll(env.GoPathDir, 0777)
	if err != nil {
		return nil, fmt.Errorf("could not create temporary GOPATH directory %v: %w", env.GoPathDir, err)
	}

	return env, nil
}

func main() {
	if len(os.Args) != 2 {
		panic("usage: go run . DOLT_REPO_HASH")
	}

	env, err := NewEnvironment(os.Args[1])
	if err != nil {
		panic(err)
	}
	defer env.Close()

	// Download the zip file of the source code.
	err = DownloadFile(env.SourceZip, env.SourceZipUrl)

	// Extract it.
	cmd := exec.Command(env.UnzipProg, env.SourceZip)
	cmd.Dir = env.BaseDir
	err = cmd.Run()
	if err != nil {
		panic(fmt.Errorf("could not run unzip on %s: %v", env.SourceZip, err))
	}

	// Run nix-hash on the extracted directory.
	srchash, err := NixHashDir(env.NixHashProg, env.SourceDir)
	if err != nil {
		panic(err)
	}

	// Download the dependencies.
	cmd = exec.Command(env.GoProg, "mod", "download")
	cmd.Dir = env.GoModuleDir
	cmd.Env = append(cmd.Env, "GOCACHE="+env.GoCacheDir)
	cmd.Env = append(cmd.Env, "GOPATH="+env.GoPathDir)
	err = cmd.Run()
	if err != nil {
		panic(fmt.Errorf("could not run `go mod download` in %s: %v", cmd.Dir, err))
	}

	// Cleanup sumdb, which does not go in the derivation and should not
	// contribute to the vendorHash.
	err = os.RemoveAll(env.GoDownloadSumDBPath)
	if err != nil {
		panic(fmt.Errorf("could not remote sumdb path at %s: %w", env.GoDownloadSumDBPath, err))
	}

	modhash, err := NixHashDir(env.NixHashProg, env.GoDownloadPath)
	if err != nil {
		panic(fmt.Errorf("could not nix-hash the download go module dependencies at %s: %w", env.GoDownloadPath, err))
	}

	type Args struct {
		Warning    string
		Revision   string
		SourceHash string
		DepsHash   string
	}
	tmpl, err := template.ParseFiles("flake.nix.template")
	if err != nil {
		panic(fmt.Errorf("could not load the nix flake template: %w", err))
	}
	err = tmpl.ExecuteTemplate(os.Stdout, "flake.nix.template", Args{
		Warning:    GeneratedFileWarning,
		Revision:   os.Args[1],
		SourceHash: srchash,
		DepsHash:   modhash,
	})
	if err != nil {
		panic(fmt.Errorf("could not render the nix flake template: %w", err))
	}
}

// Downloads the given URL to the given destination filename. The directory for
// the given filename must already exist and the file itself must not.
func DownloadFile(dest, url string) error {
	dlf, err := os.Create(dest)
	if err != nil {
		return fmt.Errorf("DownloadFile: error creating file %s: %w", dest, err)
	}
	defer dlf.Close()
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("DownloadFile: error GETing %s: %w", url, err)
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("could not fetch %s, got status code: %d", url, resp.StatusCode)
	}
	_, err = io.Copy(dlf, resp.Body)
	if err != nil {
		return fmt.Errorf("could not download entire file: %w", err)
	}
	return nil
}

// Run `nix-hash --type sha256 --base64 $dir` and return the hash for the contents of the directory.
func NixHashDir(prog, dir string) (string, error) {
	cmd := exec.Command(prog, "--type", "sha256", "--base64", ".")
	cmd.Dir = filepath.Join(dir)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("could not run nix-hash on %s: %w", dir, err)
	}
	return strings.TrimSpace(string(out)), nil
}
